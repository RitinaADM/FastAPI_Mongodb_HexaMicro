├── docker-compose.yml
└── note_service
    ├── __init__.py
    ├── app
    │   ├── __init__.py
    │   ├── application
    │   │   ├── __init__.py
    │   │   └── note_manager.py
    │   ├── core
    │   │   ├── __init__.py
    │   │   ├── config.py
    │   │   ├── container.py
    │   │   ├── dependencies.py
    │   │   └── metrics.py
    │   ├── domain
    │   │   ├── __init__.py
    │   │   ├── interfaces.py
    │   │   └── models
    │   │       ├── __init__.py
    │   │       ├── note.py
    │   │       └── user.py
    │   ├── infrastructure
    │   │   ├── __init__.py
    │   │   └── db.py
    │   ├── main.py
    │   └── presentation
    │       ├── __init__.py
    │       └── api
    │           ├── __init__.py
    │           └── notes.py
    ├── docker
    │   └── Dockerfile
    ├── requirements.txt
    └── tests
        └── test_note_manager.py

<file docker-compose.yml>
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: note_service/docker/Dockerfile
    container_name: note_service_app
    ports:
      - "8080:8000"  # Прокидываем порт FastAPI
    depends_on:
      note_service_mongodb:
        condition: service_healthy
    environment:
      - MONGO_URL=mongodb://note_service_mongodb:27017
      - DATABASE_NAME=note_service_db

  note_service_mongodb:
    image: mongo:latest
    container_name: note_service_mongodb
    restart: always
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.runCommand('ping').ok"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s

volumes:
  mongo_data:

</file docker-compose.yml>


<file note_service\requirements.txt>
fastapi==0.112.0
uvicorn==0.30.5
motor>=3.6.0
pydantic==2.8.2
pydantic-settings==2.4.0
pymongo>=4.0
prometheus-client==0.20.0
sentry-sdk==2.13.0  # Опционально для мониторинга ошибок

pytest==8.3.2
pytest-asyncio==0.23.8
</file note_service\requirements.txt>


<file note_service\__init__.py>
"""
Note Service Package
Версия: 0.1.0

Данный пакет реализует сервис управления заметками с использованием гексагональной архитектуры.
"""

__version__ = "0.1.0"

</file note_service\__init__.py>


<file note_service\app\main.py>
"""
Основная точка входа приложения Note Service.
Используется FastAPI с управлением ресурсами через lifespan, что соответствует принципам
гексагональной архитектуры: бизнес-логика (application/domain) отделена от инфраструктуры.
"""

import logging
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
from note_service.app.core.container import Container
from note_service.app.core.config import settings
from note_service.app.presentation.api.notes import router as notes_router
from note_service import __version__

# Настройка логирования с использованием конфигурации из settings
logging.basicConfig(
    level=settings.log_level,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Note Service",
    version=__version__,
    description="A simple note management microservice built with hexagonal architecture."
)

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """
    Глобальный обработчик исключений, возвращающий статус 500 при возникновении ошибки.
    """
    logger.error("Unhandled exception: %s", str(exc), extra={"context": f"request_path={request.url.path}"})
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"},
    )

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan-менеджер для инициализации и корректного завершения работы приложения.
    Здесь создаётся контейнер зависимостей и инициализируется менеджер заметок.
    """
    logger.info("Initializing application", extra={"context": "lifespan=start"})
    container = Container(settings)
    app.state.container = container
    app.state.note_manager = await container.get_note_manager()
    await app.state.note_manager.repository.init_indexes()
    logger.info("Application initialized", extra={"context": "lifespan=ready"})
    yield
    await container.close()
    logger.info("Application shutdown", extra={"context": "lifespan=shutdown"})

app.router.lifespan_context = lifespan
app.include_router(notes_router)

if __name__ == "__main__":
    import uvicorn
    logger.info("Starting Uvicorn server", extra={"context": "server=start"})
    uvicorn.run(app, host="0.0.0.0", port=8000)

</file note_service\app\main.py>


<file note_service\app\__init__.py>
from .main import app
from .core.config import settings

__all__ = ["app", "settings"]

</file note_service\app\__init__.py>


<file note_service\app\application\note_manager.py>
"""
Слой бизнес-логики для управления заметками.
Класс NoteManager реализует операции создания, получения, обновления и удаления заметок,
используя репозиторий (интерфейс) для работы с хранилищем.
"""

import logging
from typing import List
from fastapi import HTTPException
from note_service.app.domain.models.note import Note, NoteCreate, NoteUpdate
from note_service.app.domain.interfaces import NoteRepository

logger = logging.getLogger(__name__)

class NoteManager:
    """
    Менеджер заметок, отвечающий за выполнение бизнес-операций над заметками.
    """
    def __init__(self, repository: NoteRepository) -> None:
        self.repository = repository

    async def create_note(self, note: NoteCreate, user_id: str) -> Note:
        """
        Создаёт новую заметку для пользователя.
        """
        logger.info("Creating note", extra={"context": f"user_id={user_id}, title={note.title}"})
        try:
            new_note = Note(title=note.title, content=note.content, user_id=user_id)
            return await self.repository.create_note(new_note)
        except Exception as e:
            logger.error("Failed to create note: %s", str(e), extra={"context": f"user_id={user_id}"})
            raise HTTPException(status_code=500, detail="Failed to create note") from e

    async def get_note(self, note_id: str) -> Note:
        """
        Получает заметку по её идентификатору.
        """
        logger.debug("Fetching note", extra={"context": f"note_id={note_id}"})
        note = await self.repository.get_note(note_id)
        if not note:
            logger.warning("Note not found", extra={"context": f"note_id={note_id}"})
            raise HTTPException(status_code=404, detail="Note not found")
        return note

    async def update_note(self, note_id: str, note_update: NoteUpdate) -> Note:
        """
        Обновляет существующую заметку.
        """
        logger.info("Updating note", extra={"context": f"note_id={note_id}"})
        updated_note = await self.repository.update_note(note_id, note_update.dict(exclude_unset=True))
        if not updated_note:
            logger.warning("Note not found", extra={"context": f"note_id={note_id}"})
            raise HTTPException(status_code=404, detail="Note not found")
        return updated_note

    async def delete_note(self, note_id: str) -> bool:
        """
        Удаляет заметку по её идентификатору.
        """
        logger.info("Deleting note", extra={"context": f"note_id={note_id}"})
        success = await self.repository.delete_note(note_id)
        if not success:
            logger.warning("Note not found", extra={"context": f"note_id={note_id}"})
            raise HTTPException(status_code=404, detail="Note not found")
        return success

    async def get_notes_by_user(self, user_id: str) -> List[Note]:
        """
        Получает список заметок, принадлежащих указанному пользователю.
        """
        logger.debug("Fetching notes for user", extra={"context": f"user_id={user_id}"})
        notes = await self.repository.get_notes_by_user(user_id)
        logger.info("Found %d notes for user", len(notes), extra={"context": f"user_id={user_id}"})
        return notes

</file note_service\app\application\note_manager.py>


<file note_service\app\application\__init__.py>
from .note_manager import NoteManager
__all__ = ["NoteManager"]

</file note_service\app\application\__init__.py>


<file note_service\app\core\config.py>
"""
Конфигурация приложения с использованием pydantic-settings.
Значения конфигурации загружаются из переменных окружения и файла .env.
"""

from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional

class Settings(BaseSettings):
    mongo_url: str = "mongodb://localhost:27017"
    database_name: str = "note_service_db"
    log_level: str = "INFO"
    service_name: str = "note_service"
    environment: str = "development"  # Опции: development, production, test
    sentry_dsn: Optional[str] = None  # Опциональный Sentry DSN для мониторинга ошибок

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

settings = Settings()

</file note_service\app\core\config.py>


<file note_service\app\core\container.py>
"""
Контейнер зависимостей для инициализации и управления ресурсами приложения.
Реализует паттерн dependency injection для отделения бизнес-логики от инфраструктуры.
"""

import logging
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase
from note_service.app.application.note_manager import NoteManager
from note_service.app.infrastructure.db import MongoNoteRepository
from note_service.app.core.config import Settings

logger = logging.getLogger(__name__)

class Container:
    """
    Контейнер приложения, создающий и предоставляющий зависимости.
    """
    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self.client: AsyncIOMotorClient | None = None
        self.db: AsyncIOMotorDatabase | None = None

    async def get_mongo_client(self) -> tuple[AsyncIOMotorClient, AsyncIOMotorDatabase]:
        """
        Инициализирует и возвращает клиента MongoDB и базу данных.
        """
        if self.client is None:
            self.client = AsyncIOMotorClient(self.settings.mongo_url)
            self.db = self.client[self.settings.database_name]
        return self.client, self.db

    async def get_note_manager(self) -> NoteManager:
        """
        Инициализирует и возвращает экземпляр NoteManager с репозиторием.
        """
        try:
            if self.client is None or self.db is None:
                self.client, self.db = await self.get_mongo_client()
            repository = MongoNoteRepository(self.db)
            return NoteManager(repository)
        except Exception as e:
            logger.error("Failed to initialize NoteManager: %s", e)
            raise

    async def close(self) -> None:
        """
        Закрывает активное соединение с базой данных.
        """
        if self.client:
            self.client.close()
            logger.info("MongoDB connection closed")

</file note_service\app\core\container.py>


<file note_service\app\core\dependencies.py>
"""
Определение зависимостей для FastAPI.
Здесь предоставляются функции для получения текущего пользователя и менеджера заметок.
"""

from fastapi import Depends, HTTPException, Request
from note_service.app.application.note_manager import NoteManager
from note_service.app.domain.models.user import User

async def get_current_user() -> User:
    """
    Возвращает текущего пользователя (stub-реализация).
    В продакшене здесь должна быть реализована аутентификация.
    """
    return User(id="test_user_id", username="test_user")

def get_note_manager(request: Request) -> NoteManager:
    """
    Извлекает NoteManager из состояния приложения.
    """
    manager: NoteManager | None = getattr(request.app.state, "note_manager", None)
    if manager is None:
        raise HTTPException(status_code=500, detail="NoteManager not initialized")
    return manager

</file note_service\app\core\dependencies.py>


<file note_service\app\core\metrics.py>
"""
Модуль для сбора метрик с помощью Prometheus.
Определены счетчики и гистограммы для мониторинга количества запросов и задержек.
"""

from prometheus_client import Counter, Histogram

REQUEST_COUNT = Counter("note_service_requests_total", "Total number of requests", ["method", "endpoint"])
REQUEST_LATENCY = Histogram("note_service_request_latency_seconds", "Request latency in seconds", ["endpoint"])

def setup_metrics() -> None:
    """
    Заглушка для инициализации метрик, если потребуется дополнительная настройка.
    """
    pass

</file note_service\app\core\metrics.py>


<file note_service\app\core\__init__.py>
from .config import settings
from .container import Container
from .dependencies import get_current_user, get_note_manager

__all__ = ["settings", "Container", "get_current_user", "get_note_manager"]

</file note_service\app\core\__init__.py>


<file note_service\app\domain\interfaces.py>
"""
Интерфейсы доменного уровня для Note Service.
Определяет контракт для реализации репозитория заметок.
"""

from abc import ABC, abstractmethod
from typing import List, Optional
from note_service.app.domain.models.note import Note

class NoteRepository(ABC):
    @abstractmethod
    async def create_note(self, note: Note) -> Note:
        """
        Сохраняет новую заметку в хранилище.
        """
        pass

    @abstractmethod
    async def get_note(self, note_id: str) -> Optional[Note]:
        """
        Получает заметку по идентификатору.
        """
        pass

    @abstractmethod
    async def update_note(self, note_id: str, note_data: dict) -> Optional[Note]:
        """
        Обновляет данные заметки.
        """
        pass

    @abstractmethod
    async def delete_note(self, note_id: str) -> bool:
        """
        Удаляет заметку по идентификатору.
        """
        pass

    @abstractmethod
    async def get_notes_by_user(self, user_id: str) -> List[Note]:
        """
        Получает список заметок для конкретного пользователя.
        """
        pass

</file note_service\app\domain\interfaces.py>


<file note_service\app\domain\__init__.py>
from .interfaces import NoteRepository
from .models import Note, NoteView, NoteCreate, NoteUpdate, User

__all__ = ["NoteRepository", "Note", "NoteCreate", "NoteView", "NoteUpdate", "User"]

</file note_service\app\domain\__init__.py>


<file note_service\app\domain\models\note.py>
"""
Модели доменного уровня для заметок.
Определяются структуры данных с использованием pydantic.
"""

from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class Note(BaseModel):
    """
    Сущность заметки в системе.
    """
    id: Optional[str] = Field(None, alias='_id')
    title: str
    content: str
    user_id: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class NoteView(BaseModel):
    """
    Модель представления заметки для API.
    """
    id: str
    title: str
    content: str
    created_at: datetime
    updated_at: datetime

class NoteCreate(BaseModel):
    """
    Модель для создания новой заметки.
    """
    title: str
    content: str

class NoteUpdate(BaseModel):
    """
    Модель для обновления существующей заметки.
    """
    title: Optional[str] = None
    content: Optional[str] = None

</file note_service\app\domain\models\note.py>


<file note_service\app\domain\models\user.py>
"""
Модель доменного уровня для пользователя.
"""

from pydantic import BaseModel

class User(BaseModel):
    """
    Сущность пользователя в системе.
    """
    id: str
    username: str

</file note_service\app\domain\models\user.py>


<file note_service\app\domain\models\__init__.py>
from .note import Note, NoteView, NoteCreate, NoteUpdate
from .user import User

__all__ = ["Note", "NoteCreate", "NoteView", "NoteUpdate", "User"]

</file note_service\app\domain\models\__init__.py>


<file note_service\app\infrastructure\db.py>
"""
Реализация репозитория заметок для MongoDB.
Обеспечивает CRUD-операции для сущности Note с использованием библиотеки motor.
"""

from typing import List, Optional
from bson.objectid import ObjectId, InvalidId
from datetime import datetime
from note_service.app.domain.models.note import Note
from note_service.app.domain.interfaces import NoteRepository
import logging

logger = logging.getLogger(__name__)

class MongoNoteRepository(NoteRepository):
    """
    Репозиторий для работы с заметками в MongoDB.
    """
    def __init__(self, db) -> None:
        """
        Инициализирует репозиторий с заданной базой данных.
        """
        self.collection = db.get_collection("notes")

    async def init_indexes(self) -> None:
        """
        Создаёт индексы в коллекции заметок.
        """
        await self.collection.create_index("user_id")
        logger.info("Note indexes initialized")

    async def create_note(self, note: Note) -> Note:
        """
        Вставляет новую заметку в базу данных.
        """
        note_dict = note.dict(exclude={"id"})
        result = await self.collection.insert_one(note_dict)
        note.id = str(result.inserted_id)
        return note

    async def get_note(self, note_id: str) -> Optional[Note]:
        """
        Получает заметку по идентификатору.
        """
        try:
            object_id = ObjectId(note_id)
        except (InvalidId, TypeError):
            logger.debug("Invalid note_id format: %s", note_id)
            return None
        document = await self.collection.find_one({"_id": object_id})
        if document:
            document["_id"] = str(document["_id"])
            return Note.parse_obj(document)
        return None

    async def update_note(self, note_id: str, note_data: dict) -> Optional[Note]:
        """
        Обновляет существующую заметку.
        """
        try:
            object_id = ObjectId(note_id)
        except (InvalidId, TypeError):
            logger.debug("Invalid note_id format for update: %s", note_id)
            return None
        update_command = {"$set": {**note_data, "updated_at": datetime.utcnow()}}
        result = await self.collection.update_one({"_id": object_id}, update_command)
        if result.matched_count == 0:
            return None
        document = await self.collection.find_one({"_id": object_id})
        if document:
            document["_id"] = str(document["_id"])
            return Note.parse_obj(document)
        return None

    async def delete_note(self, note_id: str) -> bool:
        """
        Удаляет заметку по идентификатору.
        """
        try:
            object_id = ObjectId(note_id)
        except (InvalidId, TypeError):
            logger.debug("Invalid note_id format for deletion: %s", note_id)
            return False
        result = await self.collection.delete_one({"_id": object_id})
        return result.deleted_count > 0

    async def get_notes_by_user(self, user_id: str) -> List[Note]:
        """
        Получает все заметки для заданного пользователя.
        """
        notes: List[Note] = []
        cursor = self.collection.find({"user_id": user_id})
        async for document in cursor:
            document["_id"] = str(document["_id"])
            notes.append(Note.parse_obj(document))
        return notes

</file note_service\app\infrastructure\db.py>


<file note_service\app\infrastructure\__init__.py>
from .db import MongoNoteRepository

__all__ = ["MongoNoteRepository"]

</file note_service\app\infrastructure\__init__.py>


<file note_service\app\presentation\__init__.py>
from .api.notes import router as notes_router

__all__ = ["notes_router"]

</file note_service\app\presentation\__init__.py>


<file note_service\app\presentation\api\notes.py>
"""
API-эндпоинты для управления заметками.
Реализует CRUD-операции, используя зависимости для получения менеджера заметок и текущего пользователя.
"""

from fastapi import APIRouter, Depends, HTTPException
from typing import List
from time import time
from note_service.app.application.note_manager import NoteManager
from note_service.app.core.dependencies import get_current_user, get_note_manager
from note_service.app.domain.models.note import Note, NoteView, NoteCreate, NoteUpdate
from note_service.app.domain.models.user import User
from note_service.app.core.metrics import REQUEST_COUNT, REQUEST_LATENCY

router = APIRouter(prefix="/api/notes", tags=["notes"])

@router.post("/", response_model=NoteView)
async def create_note(
    note: NoteCreate,
    current_user: User = Depends(get_current_user),
    manager: NoteManager = Depends(get_note_manager)
) -> NoteView:
    """
    Создаёт новую заметку для текущего пользователя.
    """
    start_time = time()
    REQUEST_COUNT.labels(method="POST", endpoint="/api/notes/").inc()
    try:
        created_note = await manager.create_note(note, current_user.id)
        return created_note
    finally:
        elapsed = time() - start_time
        REQUEST_LATENCY.labels(endpoint="/api/notes/").observe(elapsed)

@router.get("/", response_model=List[NoteView])
async def list_notes(
    current_user: User = Depends(get_current_user),
    manager: NoteManager = Depends(get_note_manager)
) -> List[NoteView]:
    """
    Возвращает список всех заметок текущего пользователя.
    """
    return await manager.get_notes_by_user(current_user.id)

@router.get("/{note_id}", response_model=NoteView)
async def get_note(
    note_id: str,
    current_user: User = Depends(get_current_user),
    manager: NoteManager = Depends(get_note_manager)
) -> NoteView:
    """
    Получает заметку по идентификатору.
    """
    note = await manager.get_note(note_id)
    if note.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this note")
    return note

@router.put("/{note_id}", response_model=NoteView)
async def update_note(
    note_id: str,
    note_update: NoteUpdate,
    current_user: User = Depends(get_current_user),
    manager: NoteManager = Depends(get_note_manager)
) -> NoteView:
    """
    Обновляет существующую заметку.
    """
    note = await manager.get_note(note_id)
    if note.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to update this note")
    updated_note = await manager.update_note(note_id, note_update)
    return updated_note

@router.delete("/{note_id}", response_model=dict)
async def delete_note(
    note_id: str,
    current_user: User = Depends(get_current_user),
    manager: NoteManager = Depends(get_note_manager)
) -> dict:
    """
    Удаляет заметку по её идентификатору.
    """
    note = await manager.get_note(note_id)
    if note.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to delete this note")
    success = await manager.delete_note(note_id)
    return {"success": success}

</file note_service\app\presentation\api\notes.py>


<file note_service\app\presentation\api\__init__.py>
from .notes import router

__all__ = ["router"]

</file note_service\app\presentation\api\__init__.py>


<file note_service\docker\Dockerfile>
# Используем официальный образ Python (slim версия)
FROM python:3.11-slim

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем файл зависимостей и устанавливаем пакеты
COPY note_service/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копируем исходный код приложения
COPY note_service/ note_service/

# Запускаем приложение как модуль, добавляя /app в sys.path
CMD ["python", "-m", "note_service.app.main"]

</file note_service\docker\Dockerfile>


<file note_service\tests\test_note_manager.py>
"""
Тесты для класса NoteManager.
Используется мок-репозиторий для имитации работы с базой данных.
"""

import pytest
from fastapi import HTTPException
from note_service.app.application.note_manager import NoteManager
from note_service.app.domain.models.note import NoteCreate, Note

class MockNoteRepository:
    """
    Мок-реализация репозитория заметок для тестирования.
    """
    async def create_note(self, note: Note) -> Note:
        note.id = "mock_id"
        return note

    async def get_note(self, note_id: str) -> Note | None:
        if note_id == "mock_id":
            return Note(id="mock_id", title="Test", content="Content", user_id="user123")
        return None

    async def update_note(self, note_id: str, note_data: dict) -> Note | None:
        if note_id == "mock_id":
            return Note(id="mock_id", title=note_data.get("title", "Test"), content=note_data.get("content", "Content"), user_id="user123")
        return None

    async def delete_note(self, note_id: str) -> bool:
        return note_id == "mock_id"

    async def get_notes_by_user(self, user_id: str) -> list[Note]:
        return [Note(id="mock_id", title="Test", content="Content", user_id=user_id)]

@pytest.mark.asyncio
async def test_create_note():
    repo = MockNoteRepository()
    manager = NoteManager(repo)
    note_create = NoteCreate(title="Test", content="Content")
    user_id = "user123"

    note = await manager.create_note(note_create, user_id)

    assert note.id == "mock_id"
    assert note.title == "Test"
    assert note.content == "Content"
    assert note.user_id == "user123"

@pytest.mark.asyncio
async def test_get_note_success():
    repo = MockNoteRepository()
    manager = NoteManager(repo)

    note = await manager.get_note("mock_id")

    assert note is not None
    assert note.id == "mock_id"
    assert note.title == "Test"

@pytest.mark.asyncio
async def test_get_note_not_found():
    repo = MockNoteRepository()
    manager = NoteManager(repo)

    with pytest.raises(HTTPException) as exc_info:
        await manager.get_note("invalid_id")
    assert exc_info.value.status_code == 404

@pytest.mark.asyncio
async def test_get_notes_by_user():
    repo = MockNoteRepository()
    manager = NoteManager(repo)
    notes = await manager.get_notes_by_user("user123")
    assert len(notes) == 1
    assert notes[0].title == "Test"

</file note_service\tests\test_note_manager.py>


